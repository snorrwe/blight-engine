var N = null;var searchIndex = {};
searchIndex["blight"]={"doc":"","items":[[0,"common","blight","",N,N],[0,"aabb","blight::common","",N,N],[3,"AABB","blight::common::aabb","Axis Aligned Bounding Box",N,N],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"clone","","",0,[[["self"]],["aabb"]]],[11,"new","","",0,[[["vector2"],["f32"],["f32"]],["aabb"]]],[11,"from_radius","","",0,[[["vector2"],["vector2"]],["aabb"]]],[11,"get_center","","",0,[[["self"]],["vector2"]]],[11,"get_center_mut","","",0,[[["self"]],["vector2"]]],[11,"get_radius","","",0,[[["self"]],["vector2"]]],[11,"get_radius_mut","","",0,[[["self"]],["vector2"]]],[11,"intersects","","Test if AABB intersects with another",0,[[["self"],["aabb"]],["bool"]]],[11,"closest_point","","Calculate the closest point on the AABB to the given point",0,[[["self"],["vector2"]],["vector2"]]],[11,"closest_point_mut","","Calculate the closest point on the AABB to the given point, consuming the original point",0,[[["self"],["vector2"]],["vector2"]]],[11,"contains","","Check if `point` is inside the AABB",0,[[["self"],["vector2"]],["bool"]]],[0,"vector2","blight::common","",N,N],[3,"Vector2","blight::common::vector2","",N,N],[12,"x","","",1,N],[12,"y","","",1,N],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"clone","","",1,[[["self"]],["vector2"]]],[11,"new","","",1,[[["f32"],["f32"]],["vector2"]]],[11,"from_array","","",1,N],[11,"orthogonal","","Get a vector orthogonal to `self`",1,[[["self"]],["vector2"]]],[11,"length","","",1,[[["self"]],["f32"]]],[11,"dot","","Calculate dot product",1,[[["self"],["vector2"]],["f32"]]],[11,"sub","","Subtract a vector from `self` returning a new vector",1,[[["self"],["vector2"]],["vector2"]]],[11,"sub_mut","","Subtract a vector from `self`",1,[[["self"],["vector2"]]]],[11,"add","","Add a vector to `self` returning a new vector",1,[[["self"],["vector2"]],["vector2"]]],[11,"add_mut","","Add a vector to `self`",1,[[["self"],["vector2"]]]],[11,"get","","",1,[[["self"],["usize"]],["f32"]]],[11,"get_mut","","",1,[[["self"],["usize"]],["f32"]]],[11,"set","","",1,[[["self"],["f32"],["f32"]]]],[11,"eq","","",1,[[["self"],["vector2"]],["bool"]]],[11,"add","","",1,[[["self"],["vector2"]],["vector2"]]],[11,"sub","","",1,[[["self"],["vector2"]],["vector2"]]],[0,"circle","blight::common","",N,N],[3,"Circle","blight::common::circle","",N,N],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"clone","","",2,[[["self"]],["circle"]]],[11,"new","","",2,[[["vector2"],["f32"]],["self"]]],[11,"intersects","","",2,[[["self"],["circle"]],["bool"]]],[0,"obb","blight::common","",N,N],[3,"OBB2D","blight::common::obb","2D Oriented Bounding Box",N,N],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"clone","","",3,[[["self"]],["obb2d"]]],[11,"new","","",3,N],[11,"from_aabb","","",3,[[["aabb"]],["self"]]],[11,"from_points","","Fit an OBB onto given points  At least 3 points are required  Note that this function has a complexity of O(n2)  To avoid surprises the points must be in \"clock-wise order\"  e.g. given the points:  (1, 0) (0, 1), (1, 1), (0, 0)  a correct ordering would be  [(0, 0), (0, 1), (1, 1), (1, 0)] ```  use blight::common::vector2::Vector2;  use blight::common::obb::OBB2D;",3,N],[11,"get_center","","",3,[[["self"]],["vector2"]]],[11,"get_local","","Borrow the local coordinate space matrix",3,N],[11,"get_extents","","",3,[[["self"]],["vector2"]]],[11,"rotation_matrix","","Note that this method creates a new Matrix on each call Use `get_local` if you want to avoid copying",3,[[["self"]],["matrix22"]]],[11,"intersects_aabb","","Check if OBB2D intersects with an AABB",3,[[["self"],["aabb"]],["bool"]]],[11,"intersects","","Check if OBB2D intersects with another OBB2D",3,[[["self"],["obb2d"]],["bool"]]],[0,"matrix","blight::common","",N,N],[3,"Matrix22","blight::common::matrix","",N,N],[3,"Matrix33","","",N,N],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"clone","","",4,[[["self"]],["matrix22"]]],[18,"COLUMNS","","",4,N],[18,"ROWS","","",4,N],[18,"SIZE","","",4,N],[11,"new","","",4,N],[11,"uninitialized","","Return a new Matrix with uninitialized data",4,[[],["self"]]],[11,"get","","",4,[[["self"],["usize"],["usize"]],["f32"]]],[11,"get_mut","","",4,[[["self"],["usize"],["usize"]],["f32"]]],[11,"set","","",4,[[["self"],["usize"],["usize"],["f32"]]]],[11,"eq","","",4,[[["self"],["matrix22"]],["bool"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"clone","","",5,[[["self"]],["matrix33"]]],[18,"COLUMNS","","",5,N],[18,"ROWS","","",5,N],[18,"SIZE","","",5,N],[11,"new","","",5,N],[11,"uninitialized","","Return a new Matrix with uninitialized data",5,[[],["self"]]],[11,"get","","",5,[[["self"],["usize"],["usize"]],["f32"]]],[11,"get_mut","","",5,[[["self"],["usize"],["usize"]],["f32"]]],[11,"set","","",5,[[["self"],["usize"],["usize"],["f32"]]]],[11,"eq","","",5,[[["self"],["matrix33"]],["bool"]]],[0,"quadtree","blight::common","",N,N],[3,"Quadtree","blight::common::quadtree","",N,N],[4,"QuadtreeError","","",N,N],[13,"OutOfBounds","","",6,N],[13,"Unknown","","",6,N],[8,"Spacial","","",N,N],[10,"position","","",7,[[["self"]],["vector2"]]],[11,"new","","",8,[[["aabb"]],["self"]]],[11,"insert","","Insert a single element into the tree",8,[[["self"],["t"]],["result",["quadtreeerror"]]]],[11,"can_insert","","Check if `point` can be inserted into the tree",8,[[["self"],["t"]],["result",["quadtreeerror"]]]],[11,"insert_many","","Insert a vector of elements",8,[[["self"],["vec"]],["result",["quadtreeerror"]]]],[11,"query_range","","Queries a `range`, returns a `Vec` of references to points inside `range`",8,[[["self"],["aabb"]],["vec"]]],[11,"query_range_static","","Queries a given range and inserts the matching elements into the `result` Might be useful if you want to avoid repeated memory allocation",8,[[["self"],["aabb"],["vec"]]]],[0,"components","blight","",N,N],[0,"render","blight::components","",N,N],[3,"RenderComponent","blight::components::render","Proxy object to RenderComponents",N,N],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"clone","","",9,[[["self"]],["rendercomponent"]]],[11,"new","","",9,N],[11,"deref_mut","","",9,[[["self"]],["rendercomponentinner"]]],[11,"deref","","",9,[[["self"]],["rendercomponentinner"]]],[11,"drop","","",9,[[["self"]]]],[0,"core","blight","",N,N],[3,"BlightCore","blight::core","The hearth of the Blight Engine It's responsible for the game loop",N,N],[11,"new","","",10,[[],["blightcore"]]],[11,"get_delta_time","","",10,[[["self"]],["duration"]]],[11,"get_input","","",10,[[["self"]],["inputsystem"]]],[11,"get_render","","",10,N],[11,"run","","",10,[[["self"],["tgame"]]]],[11,"stop","","",10,[[["self"]]]],[0,"systems","blight","",N,N],[0,"input","blight::systems","",N,N],[3,"InputSystem","blight::systems::input","",N,N],[6,"EventPump","","",N,N],[6,"Event","","",N,N],[11,"new","","",11,[[["sdl"]],["inputsystem"]]],[11,"update","","",11,[[["self"]]]],[11,"handle_events","","Pass in a callback to handle each event in the current frame",11,[[["self"],["fnmut"]]]],[11,"iter_events","","Get an iterator into the events of the current frame",11,[[["self"]],["iter",["event"]]]],[0,"render","blight::systems","",N,N],[3,"RenderSystem","blight::systems::render","Handles rendering",N,N],[4,"VideoError","","",N,N],[13,"NotInitialised","","",12,N],[11,"new","","",13,[[["sdl"],["option"]],["rendersystem"]]],[11,"get_canvas","","",13,[[["self"]],["canvas"]]],[11,"get_canvas_mut","","",13,[[["self"]],["canvas"]]],[11,"set_background_color","","",13,[[["self"],["option",["color"]]]]],[11,"render","","Render all the components in the system",13,[[["self"]]]],[11,"texture_creator","","Borrow the render system's texture creator",13,[[["self"]],["texturecreator"]]],[11,"render_texture","","",13,[[["self"],["texture"],["rect"]]]],[11,"create_texture","","",13,N],[11,"create_component","","",13,[[["self"]],["rendercomponent"]]],[11,"get_components_by_ids","","",13,N],[11,"get_component_by_id","","",13,[[["self"],["usize"]],["rendercomponentinner"]]],[11,"delete_components_by_ids","","",13,N],[11,"purge_components","","",13,[[["self"]]]],[0,"render_component","","",N,N],[3,"RenderComponentInner","blight::systems::render::render_component","Represents a renderable object",N,N],[11,"new","","",14,N],[11,"get_id","","",14,[[["self"]],["usize"]]],[11,"render","","",14,[[["self"]]]],[11,"set_position","","",14,[[["self"],["rect"]]]],[11,"set_texture","","",14,N],[6,"Window","blight::systems::render","",N,N],[6,"Canvas","","",N,N],[6,"TextureCreator","","",N,N],[6,"Texture","","",N,N],[6,"TexturePtr","","",N,N],[6,"Rect","","",N,N],[17,"WINDOW_SIZE","","",N,N],[8,"Game","blight","",N,N],[10,"new","","",15,N],[11,"update","","",15,N],[14,"blight_main","","",N,N]],"paths":[[3,"AABB"],[3,"Vector2"],[3,"Circle"],[3,"OBB2D"],[3,"Matrix22"],[3,"Matrix33"],[4,"QuadtreeError"],[8,"Spacial"],[3,"Quadtree"],[3,"RenderComponent"],[3,"BlightCore"],[3,"InputSystem"],[4,"VideoError"],[3,"RenderSystem"],[3,"RenderComponentInner"],[8,"Game"]]};
initSearch(searchIndex);
